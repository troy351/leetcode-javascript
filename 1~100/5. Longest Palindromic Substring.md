#5. Longest Palindromic Substring
> Manacher 算法

**约定：下文中的：回文串n，表示：以n为中心的回文串**

* 首先在源字符串`S`每个字符之间添加`#`生成新字符串`T`，例：`S = "abc"; T = "#a#b#c#"`。  
这样能使`T`必定成为一个奇数长度的字符串，即使`T`中心位置为一个整数，方便后续操作。
* 生成一个数组`P`，`P[i]`表示**回文子串i**的长度（实际为长度的一半，即能向两边延伸的长度）。
例：
```
i = 0 1 2 3 4 5 6 7 8
T = # a # b # a # a #
P = 0 1 0 3 0 1 2 1 0
```
* 接下来研究数组`P`的特点。先看以下例子：
```
var     L         i'      C       i         R   R'
T = # b # a # b # c # b # a # b # c # b # a # c # c # b # a #
P = 0 1 0 3 0 1 0 7 0 1 0 9 0 1 0 ?
```
选择`C`位置作为观察，易得，**回文串C**从`L`开始至`R`结束，其对应数组`P`的数据也是对称的。这并非巧合，稍加思考便可得知这是一个普遍规律。  
接着研究当前所需计算的位置`i`，按照对称规律可得`P[i] == P[i']`，即`P[i] == 7`。  
但是我们验证一遍发现`P[i] == 5`而并不是`7`，这是为什么呢？  
可以看到，**回文串C**结束处为`R`，而假设`P[i] == 7`，则**回文串i**的结束位置在`R'`，超过了`R`，即**回文串i**并不是**回文串C**的子串。
在此条件下，**超出部分**（即`R`到`R'`部分）并不能保证回文，需要一个一个字符判断。  
此时我们可以确定`P[i] >= R - i`。
* 综上`P[i]`可总共分为3种情况：
  * `i + P[i'] <= C + P[C]`，即**回文串i**为**回文串C**的字串时：  
  `P[i] = P[i']`
  * `i + P[i'] > C + P[C] && i <= R`，即i仍在**回文串C**内，但并非子串时：  
  `P[i] = R - i`，然后逐步扩大`P[i]`直到不回文，再更新`C = i`
  * `i + P[i'] > C + P[C] && i > R`，即i在**回文串C**外时：  
  `P[i] = 0`，然后逐步扩大`P[i]`直到不回文，再更新`C = i`
* 最后取数组`P`中的最大值即可，记得去除添加的辅助字符`#`。
